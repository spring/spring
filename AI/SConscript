# Copyright (C) 2008 Robin Vobruba <hoijui.quaero@gmail.com>

# use ../SConstruct to build spring.
# even if you want to build only subparts of it,
# that are possibly defined in this file.

""" Available targets.
Each target has an equivalent install target. E.g. `NullAI' has
`install-NullAI' and the default target has `install'.

[default]
AIInterfaces
	C
	Java
SkirmishAI
	RAI
	NTAI
	KAI
	KAIK
	AAI
	JCAI
	NullAI
	NullLegacyCppAI
	NullJavaAI
	NullOOJavaAI
"""


Import(['env', 'ai_env'])

import os, sys
sys.path.append('rts/build/scons')
import filelist

# the next four lines are needed when compiling on windows
# (seems to be a SCons bug)
import SCons.Tool.javac
import SCons.Tool.jar
SCons.Tool.javac.generate(ai_env)
SCons.Tool.jar.generate(ai_env)


# Creates an environment for a sub-dir of the dir where env_old is used
# eg.: we are in AI/ and want an env for AI/Skirmish/,
# then the subPart is Skirmish.
def create_sub_interface(env_old, subPart):
	return env_old.Clone(
			# once we have many SConscript files (one for each sub-dir)
			# we will not need the sourcedir anymore,
			# as it will be equal to CWD
			sourcedir = os.path.join(env_old['sourcedir'], subPart),
			builddir = os.path.join(env_old['builddir'], subPart),
			installprefix = os.path.join(env_old['installprefix'], subPart)
			)

# stores shared objects so newer scons versions don't choke with
def create_shared_objects(env, fileList, suffix, additionalCPPDEFINES = []):
	objsList = []
	myEnv = env.Clone()
	myEnv.AppendUnique(CPPDEFINES = additionalCPPDEFINES)
	for f in fileList:
		while isinstance(f, list):
			f = f[0]
		fpath, fbase = os.path.split(f)
#		print "file: %s" % f
#		print "base: %s" % fbase
		fname, fext = fbase.rsplit('.', 1)
		objsList.append(myEnv.SharedObject(os.path.join(fpath, fname + suffix), f))
	return objsList


# retrieves the first line of a text file
def read_first_line(fileName, defaultValue):
	text = defaultValue
	if os.path.exists(fileName):
		file = open(fileName, 'r')
		text = file.readline().strip()
		file.close()
	return text

# retrieves the version of an AI Interface from the following file:
# {spring_source}/AI/Interfaces/${interfaceName}/VERSION
def fetch_aiInterface_version(interfaceName):
	versionFile = os.path.join('Interfaces', interfaceName, 'VERSION')
	return read_first_line(versionFile, 'UNKNOWN_VERSION')

# retrieves the version of a Skirmish AI from the following file:
# {spring_source}/AI/Skirmish/${aiName}/VERSION
def fetch_skirmishAi_version(aiName):
	versionFile = os.path.join('Skirmish', aiName, 'VERSION')
	return read_first_line(versionFile, 'UNKNOWN_VERSION')


# Installs files plus empty directories recursively,
# preserving directory structure.
def install_dir_verbatim(env, dstPath, srcPath, instList):
	if os.path.exists(srcPath):
		files = filelist.list_files_recursive(env, srcPath, exclude_dirs = False, path_relative = True)
		for f in files:
			f_src_file = os.path.join(srcPath, f)
			f_dst_path = os.path.join(dstPath, os.path.split(f)[0])
			f_dst_file = os.path.join(dstPath, f)
			if not (os.path.isdir(f_src_file) and (os.path.exists(f_dst_file) or len(os.listdir(f_src_file)) != 0)):
				instList += [env.Install(f_dst_path, f_src_file)]

# Installs files plus empty directories recursively,
# preserving directory structure.
# dstPath has to be specified relative to env['installprefix']
# and srcPath relative to CWD in the source tree
def install_dir_verbatim_rel(env, dstPath, srcPath, instList):
	dstPath_new = os.path.join(env['installprefix'], dstPath)
	return install_verbatim(env, dstPath_new, srcPath, instList)


class AWKExecutor:
	instances = {}
	awk_bin = 'awk'
	if sys.platform == 'win32':
		awk_bin = 'gawk.exe'

	myEnv = None
	myName = []
	myScripts = []
	myVars = []
	myInputFile = None
	myOutput = []
	myWorkDir = None

	def __init__(self, env, name, awkScripts, awkVars=[], inputFile = None, output = [], workDir = ''):
		AWKExecutor.instances[name] = self
		self.myEnv = env
		self.myName = name
		self.myScripts = awkScripts
		self.myVars = awkVars
		self.myInputFile = inputFile
		self.myOutput = output
		self.myWorkDir = workDir

	def createExecuteCommand(self):
		cmdLine = self.awk_bin
		for v in self.myVars:
			cmdLine += ' -v ' + v
		for s in self.myScripts:
			cmdLine += ' -f ' + s
		#cmdLine += ' $SOURCE'
		if self.myInputFile != None:
			cmdLine += ' ' + self.myInputFile
		executeCommand = self.myEnv.Command(self.myOutput, self.myInputFile, cmdLine, chdir = self.myWorkDir)
		#""" This sets up a dummy target to do the lib globbing etc. at build time """
		#executeCommand = self.myEnv.Command(self.myName + '_execute_dummyTarget', [], cmdLine)
		#env.Alias(self.myName, executeCommand)
		return executeCommand


import shutil
import exceptions
from shutil import copytree
def myCopyTree(src, dst, symlinks=False, ignore=None):
	names = os.listdir(src)
	if ignore is not None:
		ignored_names = shutil.ignore(src, names)
	else:
		ignored_names = set()
	
	if (not os.path.exists(dst)):
		os.makedirs(dst)
	errors = []
	for name in names:
		if name in ignored_names:
			continue
		srcname = os.path.join(src, name)
		dstname = os.path.join(dst, name)
		try:
			if symlinks and os.path.islink(srcname):
				linkto = os.readlink(srcname)
				os.symlink(linkto, dstname)
			elif os.path.isdir(srcname):
				myCopyTree(srcname, dstname, symlinks, ignore)
			else:
				shutil.copy2(srcname, dstname)
				# XXX What about devices, sockets etc.?
		except (IOError, os.error), why:
			errors.append((srcname, dstname, str(why)))
		# catch the Error from the recursive copytree so that we can
		# continue with other files
		except exceptions.Error, err:
			errors.extend(err.args[0])
	try:
		shutil.copystat(src, dst)
	except exceptions.WindowsError:
		# can't copy file access times on Windows
		pass
	except exceptions.OSError, why:
		errors.extend((src, dst, str(why)))
	if errors:
		raise Error, errors



class JavaProject:
	instances = {}

	#env = None
	name = []
	classPathDirs = []
	sourceDirs = []
	outDir = None
	binJarFile = None
	additionalClassPath = None

	def __init__(self, env, name, classPathDirs, sourceDirs, sourceDirs_gen, outDir, additionalClassPath = None):
		""" The first entry in sourceDirs will be the main one, which all others will have to depend on.
		Does source file globbing at build time, so source files generated during build time can be used. """
		JavaProject.instances[name] = self
		self.env = env
		self.name = name
		self.classPathDirs = classPathDirs
		self.sourceDirs = sourceDirs
		self.sourceDirs_gen = sourceDirs_gen
		self.outDir = outDir
		self.additionalClassPath = additionalClassPath
		self.doPrepareEnv()
		return

	def createClassPathPart(self, path, prefixPath = '', absolute = False):
		jarList = filelist.list_files_recursive(self.env, path, exclude_dirs = True, path_relative = True, include_regexp = '\.jar$')
		if absolute:
			prePath = SCons.Script.Dir(path).abspath
		else:
			prePath = os.path.join(prefixPath, path)
		clsPath = prePath
		for j in jarList:
			clsPath = clsPath + os.pathsep + os.path.join(prePath, j)
		return clsPath

	def createClassPath(self):
		classPath = ''
		if (self.additionalClassPath != None):
			classPath += self.additionalClassPath
		for cpd in self.classPathDirs:
			if (classPath != ''):
				classPath += os.pathsep
			classPath += self.createClassPathPart(cpd, absolute = True)
		return classPath

	def createSourcePath(self):
		sourcePath = ''
		for sd in self.sourceDirs:
			if (sourcePath != ''):
				sourcePath += os.pathsep
			sourcePath += SCons.Script.Dir(sd).abspath
		for sd in self.sourceDirs_gen:
			if (sourcePath != ''):
				sourcePath += os.pathsep
			sourcePath += SCons.Script.Dir(sd).abspath
		return sourcePath

	def doPrepareEnv(self):
		self.env['JAVACLASSPATH'] = self.createClassPath()
		self.env['JAVASOURCEPATH'] = self.createSourcePath()
		return

	def createCompileCommand(self):
		compile_cmd = self.env.Java(target = self.outDir, source = self.sourceDirs_gen[0], chdir = self.sourceDirs_gen[0])
		return compile_cmd

	def createDynamicCompileCommand(self):
		self.myDynamicCompileDummy = self.env.Command(self.name + '_compile_dummy', [], JavaProjCallback_dynamicCompile(self.name))
		self.env.Alias(self.name, self.myDynamicCompileDummy)
		return self.myDynamicCompileDummy

	def dynamicCompile_buildTime(self):
		sourceFiles = []
		for sd in self.sourceDirs_gen:
			sourceFiles += self.doSourceGlob(sd)
		#compile_cmd = self.env.Java(target = self.outDir, source = sourceFiles, chdir = self.sourceDirs_gen[0])
		compile_cmd = self.env.Java(target = self.outDir, source = self.sourceDirs + self.sourceDirs_gen, chdir = self.sourceDirs_gen[0])
		self.env.Depends(self.name, compile_cmd)
		return

	def doSourceGlob(self, path):
		#sourceFiles = glob.glob(os.path.join(path, '**/*.java'))
		sourceFiles_rel = filelist.list_files_recursive(self.env, path, exclude_dirs = True, path_relative = True, include_regexp = '\.java$')
		sourceFiles = []
		for sfr in sourceFiles_rel:
			sourceFiles += [os.path.join(path, sfr)]
		#print ''
		#print 'path: ' + path
		#print 'sourceFiles:'
		#for sf in sourceFiles:
		#	print '\t' + sf
		#print ''
		return sourceFiles

	def getExternalClassPath(self):
		extCP = createClassPath()
		if (self.binJarFile != None):
			extCP + os.pathsep + self.binJarFile
		return extCP

	def packBinJar(self, jarFile, manifestFile = None):
		myBinJarEnv = self.env.Clone(JARCHDIR = self.outDir)
		jarSource = [self.outDir]
		#jarSource[0].attributes.java_classdir = self.outDir
		#sot = SCons.Subst.Target_or_Source(self.outDir)
		#sot.attributes.java_classdir = Dir(self.outDir)
		if (manifestFile != None):
			jarSource += [manifestFile]
		packBinJar_cmd = myBinJarEnv.Jar(target = jarFile, source = jarSource)
		self.binJarFile = jarFile
		return packBinJar_cmd

	def packSrcJar(self, jarFile, manifestFile = None):
		self.srcJarFile = jarFile
		self.srcManifestFile = manifestFile
		self.namePackSrc = self.name + '_pack_src'
		#self.namePackSrc = self.name
		self.srcJarEnv = self.env.Clone()
		self.myPackSrcDummy = self.srcJarEnv.Command(self.name + '_packSrc_dummy', self.sourceDirs + self.sourceDirs_gen, JavaProjCallback_packSrc(self.name))
		self.env.Alias(self.namePackSrc, self.myPackSrcDummy)
		return self.myPackSrcDummy

	def packSrcJar_buildTime(self):
		## copy all sources to a single dir, and then pack it,
		## as the SCons Jar packager cant create multiple '-C dir's
		#tmpSrcDir = os.path.join(os.path.dirname(self.outDir), 'tmp-all-sources')
		#shutil.rmtree(tmpSrcDir, ignore_errors=True)
		#for sd in self.sourceDirs:
		#	myCopyTree(SCons.Script.Dir(sd).abspath, tmpSrcDir)
		#for sd in self.sourceDirs_gen:
		#	myCopyTree(SCons.Script.Dir(sd).abspath, tmpSrcDir)
                #
		#print ''
		#print 'tmpSrcDir: ' + tmpSrcDir
		##print 'tmpSrcDir files:'
		##for tmpsf in filelist.list_files_recursive(self.env, tmpSrcDir, exclude_dirs = True, path_relative = True, include_regexp = '\.java$'):
		##	print '\t' + tmpsf
		#print ''

		#self.srcJarEnv = self.env.Clone(JARCHDIR = tmpSrcDir)
		#self.srcJarEnv['JARCHDIR'] = tmpSrcDir
		#jarSource = [tmpSrcDir]
		#if (self.srcManifestFile != None):
		#	jarSource += [self.srcManifestFile]
		#packSrcJar_cmd = self.srcJarEnv.Jar(target = self.srcJarFile, source = jarSource, suffix = '.java')
		#self.env.Depends(self.namePackSrc, packSrcJar_cmd)
		
		createOrUpdate = 'c'
		allSourceDirs = self.sourceDirs + self.sourceDirs_gen
		
		#print ''
		#print 'sourceDirs:'
		#for sd in self.sourceDirs:
		#	print '\t' + sd
		#print 'sourceDirs_gen:'
		#for sd in self.sourceDirs_gen:
		#	print '\t' + sd
		#print 'allSourceDirs:'
		#for sd in allSourceDirs:
		#	print '\t' + sd
		#print ''
		
		for sd in allSourceDirs:
			cmdLine = 'jar ' + createOrUpdate + 'f'
			if (createOrUpdate == 'c'):
				if (self.srcManifestFile != None):
					cmdLine += 'm'
				createOrUpdate = 'u'
			cmdLine += ' ' + self.srcJarFile
			if ((createOrUpdate == 'c') and (self.srcManifestFile != None)):
				cmdLine += ' ' + self.srcManifestFile
			cmdLine += ' -C ' + SCons.Script.Dir(sd).abspath + ' .'
			print cmdLine
			os.system(cmdLine)
		#packSrcJar_cmd = self.srcJarEnv.Command(self.srcJarFile, self.sourceDirs + self.sourceDirs_gen, cmdLine)
		#self.env.Depends(self.namePackSrc, packSrcJar_cmd)
		return

# These are "callbacks" that we set up as actions that Scons can call at build time.
def javaProjCallback_dynamicCompile(libName):
	if (not (libName in JavaProject.instances)):
		raise Exception("The library %s is not defined" % libName)
	JavaProject.instances[libName].dynamicCompile_buildTime()
	return
JavaProjCallback_dynamicCompile = SCons.Action.ActionFactory(javaProjCallback_dynamicCompile, lambda name: 'Compiling "%s"' % name)

# These are "callbacks" that we set up as actions that Scons can call at build time.
def javaProjCallback_packSrc(libName):
	if (not (libName in JavaProject.instances)):
		raise Exception("The library %s is not defined" % libName)
	JavaProject.instances[libName].packSrcJar_buildTime()
	return
JavaProjCallback_packSrc = SCons.Action.ActionFactory(javaProjCallback_packSrc, lambda name: 'Packing source for "%s"' % name)



## This is only needed because the SCons internal env.Java(...) is
## heavily borked; may be removed in the future
#def ListJavaSources(env, sourcePath, pathPrefix = ''):
#	sourcesList_tmp = filelist.list_files_recursive(env, sourcePath, exclude_dirs = True, path_relative = True, include_regexp = '.*\.java$')
#	if pathPrefix != '':
#		sourcesList = []
#		for s in sourcesList_tmp:
#			sourcesList += [os.path.join(pathPrefix, s)]
#	else:
#		sourcesList = sourcesList_tmp
#	return sourcesList
## Add this command to all Environment's created/cloned from here on
#AddMethod(Environment, ListJavaSources)
#def ListJavaSourcesFunc(target, source, env):
#	sourcePath = source[0]
#	pathPrefix = source[1]
#	srcList = ListJavaSources(env, sourcePath, pathPrefix)
#	env['javaSourcesList_generated'] = srcList
#	return 0
##ListJavaSrc = SCons.Action.Action(ListJavaSourcesFunc, None, presub=None)
#ListJavaSrc = SCons.Action.Action(ListJavaSourcesFunc, None, presub=None)



#def JavaCompileFunc(target, source, env):
#	sourcesList = env['javaSourcesList_generated']
#	cmdLine = env['JavaCompile_cmdLine']
#	for s in sourcesList:
#		cmdLine += ' ' + s
#	os.system(cmdLine)
#	return 0
#JavaCompileAction = SCons.Action.Action(JavaCompileFunc, None, presub=None)
#
#
## SCons internal Java builder ... is .. bad... (trying to keep cool)
## better this way
#def JavaCompile(env, sourceDir, destDir, classPath, sourceFiles = []):
#	#sourcesList = ListJavaSources(env, sourceDir, pathPrefix = sourceDir)
#	cmdLine = 'javac'
#	cmdLine += ' -cp ' + classPath + os.pathsep + SCons.Script.Dir(sourceDir).abspath
#	cmdLine += ' -d ' + destDir
#	cmdLine += ' -sourcepath ' + SCons.Script.Dir(sourceDir).abspath
#	if sourceFiles == []:
#		sourceFiles = ListJavaSources(env, sourceDir)
#	sourceFiles_abs = []
#	for s in sourceFiles:
#		s_abs = os.path.join(sourceDir, s)
#		cmdLine += ' ' + s_abs
#		sourceFiles_abs += [s_abs]
#	#env['JavaCompile_cmdLine'] = cmdLine
#	#for s in sourcesList:
#	#	cmdLine += ' ' + s
#	#print "JavaCompile: cmdLine: %s" % cmdLine
#	#os.system(cmdLine)
#	#classFilesDep = env.Command(target, sourcesList, cmdLine)
#	#return env.Command(destDir, sourcesList,
#	#	[
#	#	#ListJavaSrc(sourceDir, pathPrefix = sourceDir),
#	#	ListJavaSrc(source = [sourceDir, sourceDir]),
#	#	JavaCompileAction()
#	#	])
#	#listSrcCmd = env.Command(destDir, sourceDir, ListJavaSrc([sourceDir, sourceDir]))
#	#return env.Command(destDir, listSrcCmd, JavaCompileAction(listSrcCmd))
#	#return env.Command(destDir, sourceDir, JavaCompileAction())
#	return env.Command(destDir, sourceFiles_abs, [Mkdir(destDir), cmdLine])
#	#return env.Command(destDir, sourcesList, cmdLine,
#        #             suffix = '.class',
#        #             src_suffix = '.java')
#	#if classFiles == []:
#	#	raise SCons.Errors.UserError("No class files created")
#	#return classFiles
##def generate_actions(source, target, env, for_signature):
##           return 'foobuild < %s > %s' % (source[0], target[0])
##       bld = Builder(generator = generate_actions,
##                     suffix = '.foo',
##                     src_suffix = '.input')
##       env = Environment(BUILDERS = {'Foo' : bld})
##       env.Foo('file')
#AddMethod(Environment, JavaCompile)


#def createJavaClasspath(env, path, prefixPath = '', absolute = False):
#	## helper function to get a list of all subdirectories
#	#def addJars(jarList, dirname, names):
#	#	# internal function to pass to os.path.walk
#	#	for n in names:
#	#		f = os.path.join(dirname, n)
#	#		if os.path.isfile(f) and os.path.splitext(f)[1] == ".jar":
#	#			jarList.append(f)
#	#jarList = []
#	#os.path.walk(path, addJars, jarList)
#	jarList = filelist.list_files_recursive(env, path, exclude_dirs = True, path_relative = True, include_regexp = '\.jar$')
#	# concatenate list elements to a class-path string
#	#clsPath = os.path.join(prefixPath, path)
#	#for j in jarList:
#	#	clsPath = clsPath + os.pathsep + os.path.join(prefixPath, path, j)
#	if absolute:
#		prePath = SCons.Script.Dir(path).abspath
#	else:
#		prePath = os.path.join(prefixPath, path)
#	clsPath = prePath
#	for j in jarList:
#		clsPath = clsPath + os.pathsep + os.path.join(prePath, j)
#	return clsPath


#def JavaCompile(env, scriptFiles, inputFile, output, cmdVars = [], workingDir = ''):
#	myEnv['JAVACLASSPATH'] = javaInterfaceCP
#	myEnv['JAVASOURCEPATH'] = javaSrc
#	myClasses = myEnv.Java(target = javaClasses, source = javaSrc)
#	myEnv['JARCHDIR'] = [javaClasses]
#	myJar = myEnv.Jar(target = javaJar, source = myClasses)
#	return 0
#
#
#def JavaCompile(env, sources, classesDir, sourceDir = '', classPath = '.'):
#	cmdLine = awk_bin
#	for v in cmdVars:
#		cmdLine += ' -v ' + v
#	for f in scriptFiles:
#		cmdLine += ' -f ' + f
#	#cmdLine += ' $SOURCE'
#	cmdLine += ' ' + inputFile
#	print cmdLine
#	#localEnv = env.Clone()
#	#awkBld = localEnv.Builder(action = cmdLine, chdir = workingDir)
#	#localEnv.Append(BUILDERS = {'AWKScript' : awkBld})
#	#awkResult = localEnv.AWKScript(source = inputFile, target = output)
#	awkResult = env.Command(output, inputFile, cmdLine, chdir = workingDir)
#	return awkResult
#AddMethod(Environment, AWKScript)
#
#		COMMAND "${JAVA_COMPILE}" ARGS
#		"-cp" "${CLASSPATH_INTERNAL}"
#		"-d" "${JAVA_BUILD_DIR}"
#		${JAVA_GENERATED_SOURCES}
#		WORKING_DIRECTORY "${JAVA_GENERATED_SRC_DIR}"
#		COMMENT "  Compiling Java sources ..." VERBATIM)
#

################################################################################
### Setup the envs
################################################################################
# Make a copy of the build environment for the AIs, but remove libraries and add include path.
# TODO: make separate SConstructs for AIs
#ai_env = env.Clone()
#ai_env = env.Clone(builddir=os.path.join(env['builddir'], 'AI'))
#ai_env['LIBS'] = []

ai_env.AppendUnique(CPPPATH = ['#rts/ExternalAI'])
ai_env.AppendUnique(LINKFLAGS = ['-lstdc++'])
# set sourcedir to '', which equals CWD
ai_env['sourcedir'] = ''
if ai_env['platform'] == 'windows':
	ai_env.AppendUnique(LINKFLAGS = ['-Wl,--kill-at', '--add-stdcall-alias', '-mno-cygwin'])
#print ai_env['CPPDEFINES']

#for d in filelist.list_directories(ai_env, SCons.Script.Dir('#rts').abspath, exclude_list=["crashrpt"]):
#	ai_env.BuildDir(os.path.join(ai_env['builddir'], 'Interfaces', d), d)
#	#print "d pj: %s" % os.path.join(ai_env['builddir'], 'Interfaces', d)
#	#print "d: %s" % d

#ai_env.BuildDir(os.path.join(ai_env['builddir'], 'tools/unitsync'), 'tools/unitsync')

#bld_JavaCompile = Builder(action = JavaCompile)
#ai_env['BUILDERS']['JavaCompile'] = bld_JavaCompile

aiinterface_env = create_sub_interface(ai_env, 'Interfaces')
aiinterface_env.AppendUnique(CPPDEFINES = ['BUILDING_AI_INTERFACE'])

skirmishai_env = create_sub_interface(ai_env, 'Skirmish')
skirmishai_env.AppendUnique(CPPDEFINES = ['BUILDING_AI'])


################################################################################
### Build AI Interface shared objects
################################################################################
#install_aiinterfaces_dir = os.path.join(aiinterface_env['installprefix'], aiinterface_env['datadir'], 'AI', 'Interfaces')
#print("aiinterface_env:")
#print(aiinterface_env.Dump())

# Store shared ai-interface objects, so newer SCons versions do not choke with:
# *** Two environments with different actions were specified for the same target
aiinterfaceobjs_main = create_shared_objects(aiinterface_env, filelist.get_shared_AIInterface_source(env), '-aiinterface')
aiinterfaceobjs_SharedLib = create_shared_objects(aiinterface_env, filelist.get_shared_AIInterface_source_SharedLib(env), '-aiinterface')
aiinterfaceobjs_CUtils = create_shared_objects(aiinterface_env, filelist.get_shared_Wrapper_source(ai_env, 'CUtils'), '-aiinterface')

# Build
aiinterfaces_exclude_list=['build']
aiinterfaces_needSharedLib_list=['C']
aiinterfaces_needStreflop_list=['Java']
aiinterfaces_needCUtils_list=['C', 'Java']

# These two will be filled here and used by Java Skirmish AIs further down
#javaInterfaceCP = ''
#javaInterfaceJar = ''
javaAiInterfaceProj = None

for baseName in filelist.list_AIInterfaces(aiinterface_env, exclude_list=aiinterfaces_exclude_list):
	aiInterfaceVersion = fetch_aiInterface_version(baseName)
	print "Found AI Interface: " + baseName + " " + aiInterfaceVersion
	myEnv = create_sub_interface(aiinterface_env, baseName)
	myEnv['installprefix'] = os.path.join(myEnv['installprefix'], aiInterfaceVersion)
	instList = []
	objs = []
	objs += aiinterfaceobjs_main
	if baseName in aiinterfaces_needSharedLib_list:
		objs += aiinterfaceobjs_SharedLib
	if baseName in aiinterfaces_needCUtils_list:
		myEnv.AppendUnique(CPPPATH = ['Wrappers'])
		objs += aiinterfaceobjs_CUtils
	if baseName in aiinterfaces_needStreflop_list:
		if myEnv['fpmath'] == 'sse':
			myEnv.AppendUnique(CPPDEFINES=['STREFLOP_SSE'])
		else:
			myEnv.AppendUnique(CPPDEFINES=['STREFLOP_X87'])
		myEnv.AppendUnique(CPPPATH = ['#rts/lib/streflop'])
		myEnv.AppendUnique(LIBS = [myEnv['streflop_lib']])
	mySource = objs + filelist.get_source(myEnv, myEnv['sourcedir'], ignore_builddir=True)
# TODO: REVIEW FROM HERE ...
	if baseName == 'Java':
		if myEnv['platform'] == 'windows':
			myEnv.AppendUnique(LIBS = ['jvm'])

		# generate class files
		springSrcDir = SCons.Script.Dir('..').abspath
		springInterfaceSrcDir = os.path.join(springSrcDir, 'rts', 'ExternalAI', 'Interface')
		#print("springInterfaceSrcDir: " + springInterfaceSrcDir)
		#springInterfaceSrcDir = os.path.join( '#rts', 'ExternalAI', 'Interface')
		interfaceJLibDir = os.path.join(myEnv['sourcedir'], 'data', 'jlib')
		interfaceJavaSrcDir = os.path.join(myEnv['sourcedir'], 'java', 'src')
		interfaceManifestFile = os.path.join(interfaceJavaSrcDir, 'manifest.mf')
		interfaceBinDir = os.path.join('AI', myEnv['sourcedir'], 'bin')
		awkScriptsDir = interfaceBinDir
		interfaceGeneratedJavaSrcDir = os.path.join(myEnv['builddir'], 'generated-java-src')
		interfaceTmpAllSrcDir = os.path.join(myEnv['builddir'], 'tmp-all-src')
		interfaceJavaClassesDir = os.path.join(myEnv['builddir'], 'classes')
		javaPkg = 'com/clan_sy/spring/ai'
		jarFileBase = 'AIInterface'
		jarFileBin = jarFileBase + '.jar'
		jarFileSrc = jarFileBase + '-src.jar'
		jarFileBin_build = os.path.join(myEnv['builddir'], jarFileBin)
		jarFileSrc_build = os.path.join(myEnv['builddir'], jarFileSrc)
		genSrcPkgDir = os.path.join(interfaceGeneratedJavaSrcDir, javaPkg)
		#interfaceJLibs = createJavaClasspath(myEnv, interfaceJLibDir, absolute = True)
		## For compiling the interface
		#interfaceJavaClassPath = interfaceJLibs # + os.pathsep + SCons.Script.Dir(interfaceJavaSrcDir).abspath
		## For Java AIs
		#javaInterfaceCP = interfaceJLibs + os.pathsep + jarFileBin_build

		if not os.path.exists(os.path.join(genSrcPkgDir, 'event')):
			os.makedirs(os.path.join(genSrcPkgDir, 'event'))
			os.makedirs(os.path.join(genSrcPkgDir, 'command'))
			os.makedirs(os.path.join(genSrcPkgDir, 'oo'))

		awkVars = []
		awkVars += ['SPRING_SOURCE_DIR=' + springSrcDir]
		awkVars += ['INTERFACE_SOURCE_DIR=' + interfaceJavaSrcDir]
		awkVars += ['GENERATED_SOURCE_DIR=' + interfaceGeneratedJavaSrcDir]

		# wrapp the AI Events
		awkScripts = []
		awkScripts += ['jna_wrappEvents.awk']
		awkScripts += ['common.awk']
		awkScripts += ['commonDoc.awk']
		awkInputFile = os.path.join(springInterfaceSrcDir, 'AISEvents.h')
		awkOutput = [os.path.join(genSrcPkgDir, 'event', 'InitAIEvent.java')]
		wrapp_events = AWKExecutor(myEnv, 'wrapp_events', awkScripts, awkVars, awkInputFile, awkOutput, workDir = awkScriptsDir)
		wrapp_events_cmd = wrapp_events.createExecuteCommand()

		#myEnv.AddPreAction(generate_events, [
		#		Mkdir(os.path.join(genSrcPkgDir, 'event')),
		#		Mkdir(os.path.join(genSrcPkgDir, 'command')),
		#		Mkdir(os.path.join(genSrcPkgDir, 'oo')),
		#		])
		#if not os.path.join(genSrcPkgDir, 'event').exists():
		#	print "DIR: NOT EXISTS"
		#else:
		#	print "DIR: EXISTS"

		# wrapp the Commands
		awkScripts = []
		awkScripts += ['jna_wrappCommands.awk']
		awkScripts += ['common.awk']
		awkScripts += ['commonDoc.awk']
		awkInputFile = os.path.join(springInterfaceSrcDir, 'AISCommands.h')
		awkOutput = [os.path.join(genSrcPkgDir, 'command', 'BuildUnitAICommand.java')]
		wrapp_commands = AWKExecutor(myEnv, 'wrapp_commands', awkScripts, awkVars, awkInputFile, awkOutput, workDir = awkScriptsDir)
		wrapp_commands_cmd = wrapp_commands.createExecuteCommand()

		# wrapp the Callback
		awkScripts = []
		awkScripts += ['jna_wrappCallback.awk']
		awkScripts += ['common.awk']
		awkScripts += ['commonDoc.awk']
		awkInputFile = os.path.join(springInterfaceSrcDir, 'SAICallback.h')
		awkOutput = [os.path.join(genSrcPkgDir, 'AICallback.java')]
		wrapp_callback = AWKExecutor(myEnv, 'wrapp_callback', awkScripts, awkVars, awkInputFile, awkOutput, workDir = awkScriptsDir)
		wrapp_callback_cmd = wrapp_callback.createExecuteCommand()

		# wrapp the Callback in an OO layer
		awkScripts = []
		awkScripts += ['java_wrappCallbackOO.awk']
		awkScripts += ['common.awk']
		awkScripts += ['commonDoc.awk']
		awkScripts += ['commonOOCallback.awk']
		awkInputFile = os.path.join(interfaceGeneratedJavaSrcDir, javaPkg, 'AICallback.java')
		awkOutput = [
				os.path.join(genSrcPkgDir, 'oo', 'OOAICallback.java'),
				# if you add these, scons will delete them (WHYYYYYYYYYY!?!?!?!)
				#os.path.join(genSrcPkgDir, 'oo', 'OOAIFactory.java'),
				#os.path.join(genSrcPkgDir, 'oo', 'AbstractOOAI.java'),
				]
		wrapp_callbackOO = AWKExecutor(myEnv, 'wrapp_callbackOO', awkScripts, awkVars, awkInputFile, awkOutput, workDir = awkScriptsDir)
		wrapp_callbackOO_cmd = wrapp_callbackOO.createExecuteCommand()

		wrapp_all = [wrapp_events_cmd, wrapp_commands_cmd, wrapp_callback_cmd, wrapp_callbackOO_cmd]


		# compile the Java part
		aiInterfaceProj = JavaProject(myEnv, 'aiInterfaceProj', [interfaceJLibDir], [SCons.Script.Dir(interfaceJavaSrcDir).abspath], [interfaceGeneratedJavaSrcDir], interfaceJavaClassesDir)
		javaAiInterfaceProj = aiInterfaceProj
		# Dynamic compilation takes way too long!
		aiInterfaceProj_compile_cmd = aiInterfaceProj.createCompileCommand()
		#aiInterfaceProj_compile_cmd = aiInterfaceProj.createDynamicCompileCommand()
		myClasses = aiInterfaceProj_compile_cmd

		#generatedSourceFiles = myEnv.ListJavaSources(interfaceGeneratedJavaSrcDir, pathPrefix = interfaceGeneratedJavaSrcDir)
		
		# pack the java binaries
		##myEnv['JARCHDIR'] = interfaceJavaClassesDir
		#myBinJarEnv = myEnv.Clone(JARCHDIR = interfaceJavaClassesDir)
		##myJarBin = myEnv.Jar(target = jarFileBin_build, source = myClasses)
		#myJarBin = myBinJarEnv.Jar(target = jarFileBin_build, source = [interfaceJavaClassesDir, interfaceManifestFile])
		aiInterfaceProj_packBin_cmd = aiInterfaceProj.packBinJar(jarFileBin_build, interfaceManifestFile)
		myJarBin = aiInterfaceProj_packBin_cmd

		# pack the java sources
		#myEnv['JARCHDIR'] = [interfaceGeneratedJavaSrcDir]
		#mySrcJarEnv = myEnv.Clone(JARCHDIR = [interfaceGeneratedJavaSrcDir, interfaceJavaSrcDir])
		## This will be fail, most likely, as we would have to set
		## a separate JARDIR for each source dir
		#myJarSrc = mySrcJarEnv.Jar(target = jarFileSrc_build, source = [interfaceGeneratedJavaSrcDir, interfaceJavaSrcDir], suffix = '.java')
		
		#mySrcJarEnv = myEnv.Clone(JARCHDIR = interfaceTmpAllSrcDir)
		
		#myJarSrc = mySrcJarEnv.Jar(target = jarFileSrc_build, source = interfaceTmpAllSrcDir, suffix = '.java')
		#
		#mySrcJarEnv.AddPreAction(myJarSrc, [
		#		Delete(interfaceTmpAllSrcDir),
		#		Mkdir(interfaceTmpAllSrcDir),
		#		Copy(interfaceTmpAllSrcDir, os.path.join(interfaceJavaSrcDir, '*')),
		#		Copy(interfaceTmpAllSrcDir, os.path.join(interfaceGeneratedJavaSrcDir, '*'))
		#		])
		#mySrcJarEnv.AddPostAction(myJarSrc, [
		#		Delete(interfaceTmpAllSrcDir)
		#		])

		#myJarSrc = mySrcJarEnv.Command(jarFileSrc_build, interfaceTmpAllSrcDir, [
		#		Delete(interfaceTmpAllSrcDir),
		#		Mkdir(interfaceTmpAllSrcDir),
		#		Copy(Dir(interfaceTmpAllSrcDir), Dir(interfaceJavaSrcDir).abspath),
		#		Copy(Dir(interfaceTmpAllSrcDir), os.path.join(interfaceGeneratedJavaSrcDir, '')),
		#		mySrcJarEnv.Jar(target = jarFileSrc_build, source = interfaceTmpAllSrcDir, suffix = '.java'),
		#		Delete(interfaceTmpAllSrcDir)
		#		])
		aiInterfaceProj_packSrc_cmd = aiInterfaceProj.packSrcJar(jarFileSrc_build)
		myJarSrc = aiInterfaceProj_packSrc_cmd

		#myJarSrc = mySrcJarEnv.Command(interfaceTmpAllSrcDir, [SCons.Script.Dir(interfaceJavaSrcDir), interfaceGeneratedJavaSrcDir], [
		#		Delete(interfaceTmpAllSrcDir),
		#		#Mkdir(interfaceTmpAllSrcDir),
		#		Copy("$TARGET", "$SOURCE"),
		#		mySrcJarEnv.Jar(target = jarFileSrc_build, source = interfaceTmpAllSrcDir, suffix = '.java'),
		#		Delete(interfaceTmpAllSrcDir)
		#		])


		#allBuilds = [generate_all, myJarBin, myJarSrc]
		allBuilds = [wrapp_all, myClasses, myJarBin, myJarSrc]
		Alias(baseName, allBuilds)
		Alias('AIInterfaces', allBuilds)
		Default(allBuilds)
		
#		javaSrc = os.path.join('Interfaces', baseName, 'java/src')
#		javaClasses = os.path.join(myEnv['builddir'], 'Interfaces', baseName, aiInterfaceVersion, 'classes')
#		#javaJar = os.path.join(myEnv['builddir'], 'Interfaces', baseName, aiInterfaceVersion, 'interface.jar')
#		#javaInterfaceJar = javaJar
#		javaInterfaceJar = os.path.join('Interfaces', baseName, aiInterfaceVersion, 'AIInterface.jar')
#		javaJar = os.path.join(myEnv['builddir'], javaInterfaceJar)
#		javaInterfaceJar = os.path.join('build', 'AI', javaInterfaceJar)
#		javaInterfaceSrcJar = os.path.join('Interfaces', baseName, aiInterfaceVersion, 'AIInterface-src.jar')
#		jlibDir = os.path.join('Interfaces', baseName, 'data', 'jlib')
#		javaInterfaceCP = createJavaClasspath(jlibDir, 'AI')

#		myEnv['JAVACLASSPATH'] = javaInterfaceCP
#		myEnv['JAVASOURCEPATH'] = javaSrc
#		myClasses = myEnv.Java(target = javaClasses, source = javaSrc)
#		myEnv['JARCHDIR'] = [javaClasses]
#		myJar = myEnv.Jar(target = javaJar, source = myClasses)
#		Alias(baseName, myJar)
#		Alias('AIInterfaces', myJar)
#		Default(myJar)
#		instList += [myEnv.Install(install_data_interface_dir, myJar)]
		#installDataDir(myEnv, install_data_interface_dir, jlibDir, instList)
# TODO: ... TILL HERE

	#targetName = baseName + '-' + aiInterfaceVersion
	targetName = 'AIInterface'
	lib = myEnv.SharedLibrary(os.path.join(myEnv['builddir'], targetName), mySource)
	Alias(baseName, lib)       # Allow e.g. `scons Java' to compile just that specific AI interface.
	Alias('AIInterfaces', lib) # Allow `scons AIInterfaces' to compile all AI interfaces.
	Default(lib)
	instList += [myEnv.Install(myEnv['installprefix'], lib)]
	if myEnv['strip']:
		myEnv.AddPostAction(lib, Action([['strip','$TARGET']]))

	# record data files (eg InterfaceInfo.lua or config files) for installation
	source_data_dir = os.path.join(myEnv['sourcedir'], 'data')
	install_dir_verbatim(myEnv, myEnv['installprefix'], source_data_dir, instList)

	Alias('install', instList)
	Alias('install-AIInterfaces', instList)
	Alias('install-' + baseName, instList)

################################################################################
### Build Skirmish AI shared objects
################################################################################
#print ""
#print "installprefix: %s" % skirmishai_env['installprefix']
#print "datadir: %s" % skirmishai_env['datadir']
#print "prefix: %s" % skirmishai_env['prefix']
install_skirmishai_dir = os.path.join(skirmishai_env['installprefix'], skirmishai_env['datadir'], 'AI', 'Skirmish')
#print "install_skirmishai_dir.abspath: %s" % SCons.Script.Dir(install_skirmishai_dir).abspath
#install_skirmishai_dir = os.path.join('Skirmish')

# store shared ai objects so newer scons versions don't choke with
# *** Two environments with different actions were specified for the same target
skirmishaiobjs_main = create_shared_objects(skirmishai_env, filelist.get_shared_skirmishAI_source(env), '-skirmishai')
skirmishaiobjs_mainCregged = create_shared_objects(skirmishai_env, filelist.get_shared_skirmishAI_source(env), '-skirmishai_creg', ['USING_CREG'])
skirmishaiobjs_creg = create_shared_objects(skirmishai_env, filelist.get_shared_skirmishAI_source_Creg(env), '-skirmishai_creg', ['USING_CREG'])
skirmishaiobjs_LegacyCpp = create_shared_objects(skirmishai_env, filelist.get_shared_skirmishAI_source_LegacyCpp(env), '-skirmishai')
skirmishaiobjs_LegacyCppCregged = create_shared_objects(skirmishai_env, filelist.get_shared_skirmishAI_source_LegacyCpp(env), '-skirmishai_creg', ['USING_CREG'])

# Build
skirmishai_exclude_list=['build', 'CSAI', 'TestABICAI', 'AbicWrappersTestAI', 'NullJavaAI', 'NullOOJavaAI']
# for some strange reason, NTai has a compile error
# when compiling with MinGW on windows, because of
# a class in the Legacy C++ wrapper, which is used
# by all other legacy C++ AIs aswell
if sys.platform == 'win32':
	skirmishai_exclude_list += ['NTai']
skirmishai_isLegacyCpp_list=['AAI', 'KAIK', 'RAI', 'NullLegacyCppAI', 'KAI', 'NTai']
skirmishai_needCreg_list=['KAIK', 'KAI']
skirmishai_needBoost_list=['NTai']
skirmishai_isJava_list=['NullJavaAI', 'NullOOJavaAI']
for baseName in filelist.list_skirmishAIs(skirmishai_env, exclude_list=skirmishai_exclude_list):
	aiVersion = fetch_skirmishAi_version(baseName)
	print "Found Skirmish AI: " + baseName + " " + aiVersion
	isLegacyCpp = baseName in skirmishai_isLegacyCpp_list
	useCreg = baseName in skirmishai_needCreg_list
	useBoost = baseName in skirmishai_needBoost_list
	isJava = baseName in skirmishai_isJava_list
	myEnv = create_sub_interface(skirmishai_env, baseName)
	myEnv['installprefix'] = os.path.join(myEnv['installprefix'], aiVersion)
	instList = []

	# create the library
	#if not isJava:
	if isJava:
## TODO: REVIEW FROM HERE ...
#		javaSrc = os.path.join(myEnv['sourcedir'], 'src')
#		javaClasses = os.path.join(myEnv['builddir'], 'classes')
#		javaJar = os.path.join(myEnv['builddir'], 'SkirmishAI.jar')
#		jlibDir = os.path.join(myEnv['sourcedir'], 'data', 'jlib')
#		aiCP = createJavaClasspath(jlibDir, 'AI')
#		aiFullCP = aiCP + os.pathsep + javaInterfaceJar + os.pathsep + javaInterfaceCP
#		myEnv['JAVACLASSPATH'] = aiFullCP
#		myEnv['JAVASOURCEPATH'] = javaSrc
#		myClasses = myEnv.Java(target = javaClasses, source = javaSrc)
#		myEnv['JARCHDIR'] = [javaClasses]
#		myJar = myEnv.Jar(target = javaJar, source = myClasses)

		javaSrc = os.path.join(myEnv['sourcedir'], 'src')
		javaClasses = os.path.join(myEnv['builddir'], 'classes')
		manifestFile = os.path.join(javaSrc, 'manifest.mf')
		jarFileBase = 'SkirmishAI'
		jarFileBin = jarFileBase + '.jar'
		jarFileSrc = jarFileBase + '-src.jar'
		jarFileBin_build = os.path.join(myEnv['builddir'], jarFileBin)
		jarFileSrc_build = os.path.join(myEnv['builddir'], jarFileSrc)

		skirmishAiProj = JavaProject(myEnv, 'skirmishAiProj-' + baseName, [myJLibDir], [SCons.Script.Dir(javaSrc).abspath], [], javaClasses, additionalClassPath = javaAiInterfaceProj.getExternalClassPath())

		myCompile_cmd = skirmishAiProj.createCompileCommand()
		myBinJar_cmd = skirmishAiProj.packBinJar(jarFileBin_build, manifestFile)
		mySrcJar_cmd = skirmishAiProj.packSrcJar(jarFileSrc_build)
		doAllJava = [myCompile_cmd, myBinJar_cmd, mySrcJar_cmd]
## TODO: ... TILL HERE
		Alias(baseName, doAllJava)
		Alias('SkirmishAI', doAllJava)
		Default(doAllJava)
		instList += [myEnv.Install(myEnv['installprefix'], jarFileBin_build)]
		instList += [myEnv.Install(os.path.join(myEnv['installprefix'], 'jlib'), jarFileSrc_build)]
#		#installDataDir(myEnv, install_data_ai_dir, jlibDir, instList)
#
	else:
		#if useBoost:
		#	# This code is stolen from config.py
		#	boost_thread = ['boost_thread']
		#	boost_regex  = ['boost_regex']
		#	if myEnv.Dictionary('CC').find('gcc') != -1: gcc = True
		#	else: gcc = False
		#	for boost in (boost_thread, boost_regex):
		#		l = boost[0]
		#		if gcc: boost = [l+'-gcc-mt', l+'-mt', l+'-gcc', l]
		#		else:   boost = [l+'-mt', l]
		#		myEnv.AppendUnique(LIBS = boost)
		#	#myEnv.AppendUnique(LIBS = boost_regex.libraries)
		if useCreg:
			myEnv.AppendUnique(CPPDEFINES = ['USING_CREG'])
		objs = []
		if useCreg:
			objs += skirmishaiobjs_mainCregged
			objs += skirmishaiobjs_creg
		else:
			objs += skirmishaiobjs_main
		if isLegacyCpp:
			myEnv.AppendUnique(CPPPATH = ['Wrappers'])
			if useCreg:
				objs += skirmishaiobjs_LegacyCppCregged
			else:
				objs += skirmishaiobjs_LegacyCpp
		mySource = objs + filelist.get_source(myEnv, myEnv['sourcedir'], ignore_builddir=True)
		#targetName = baseName + '-' + aiVersion
		targetName = 'SkirmishAI'
		lib = myEnv.SharedLibrary(os.path.join(myEnv['builddir'], targetName), mySource)
		Alias(baseName, lib)     # Allow e.g. `scons JCAI' to compile just a skirmish AI.
		Alias('SkirmishAI', lib) # Allow `scons SkirmishAI' to compile all skirmishAIs.
		Default(lib)
		instList += [myEnv.Install(myEnv['installprefix'], lib)]
		if myEnv['strip']:
			myEnv.AddPostAction(lib, Action([['strip','$TARGET']]))

	# record data files (eg AIInfo.lua or config files) for installation
	source_data_dir = os.path.join(myEnv['sourcedir'], 'data')
	install_dir_verbatim(myEnv, myEnv['installprefix'], source_data_dir, instList)

	# install everything from this AI
	Alias('install', instList)
	Alias('install-SkirmishAI', instList)
	Alias('install-' + baseName, instList)

