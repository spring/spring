/*
	Copyright (c) 2008 Robin Vobruba <hoijui.quaero@gmail.com>

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

	@author	Robin Vobruba <hoijui.quaero@gmail.com>
*/

#ifndef __SKIRMISH_AI_HANDLER_H
#define __SKIRMISH_AI_HANDLER_H

#include "ExternalAI/SkirmishAIData.h"

#include "creg/creg_cond.h"

#include <map>
#include <set>


class CGameSetup;
class SkirmishAIKey;

/**
 * Handles all Skirmish AI instance relevant data, which includes,
 * but is not limited to all sync relevant Skirmish AI stuff.
 */
class CSkirmishAIHandler
{
private:
	CR_DECLARE(CSkirmishAIHandler);

	CSkirmishAIHandler();
	~CSkirmishAIHandler();

public:
	//typedef std::vector<SkirmishAIData*> ais_t;
	typedef std::vector<size_t> ids_t;

	/**
	 * Fetcher for the singleton.
	 */
	static CSkirmishAIHandler& GetInstance();

	void LoadFromSetup(const CGameSetup& setup);

	/**
	 * @brief SkirmishAIData
	 * @param skirmishAIId index to fetch
	 * @return SkirmishAIData pointer
	 *
	 * Accesses the data of a Skirmish AI instance at a given index.
	 */
	SkirmishAIData* GetSkirmishAI(const size_t skirmishAIId);

	/**
	 * @brief SkirmishAIData
	 * @param name name of the Skirmish AI instance
	 * @return its index or -1 if not found
	 *
	 * Search a Skirmish AI instance by name.
	 */
	size_t GetSkirmishAI(const std::string& name) const;

	/**
	 * @brief Skirmish AIs controlling a team
	 * 
	 * Will change during runtime (Connection lost, died, killed, created, ...).
	 */
	ids_t GetSkirmishAIsInTeam(const int teamId, const int playerId = -1);

	/**
	 * @brief Skirmish AIs hosted by a player
	 * 
	 * Will change during runtime (Connection lost, died, killed, created, ...).
	 */
	ids_t GetSkirmishAIsByPlayer(const int playerId);

	/**
	 * @brief All active Skirmish AIs
	 * 
	 * Will change during runtime (Connection lost, died, killed, created, ...).
	 */
	ids_t GetAllSkirmishAIs();

	/**
	 * @brief Adds a Skirmish AI
	 * @param data the Skirmish AI to add
	 * @param skirmishAIId id of the Skirmish AI, generated by
	 *                     and received from the server
	 */
	void AddSkirmishAI(const SkirmishAIData& data, const size_t skirmishAIId);

	/**
	 * @brief Removes a Skirmish AI
	 * @param data the Skirmish AI to add
	 * @return true if an Skirmish AI was removed
	 */
	bool RemoveSkirmishAI(const size_t skirmishAIId);

	/**
	 * @brief Number of players the game was created for
	 * 
	 * Constant at runtime
	 */
	size_t GetNumSkirmishAIs() const;

	/**
	 * Called when a Skirmish AI left the scene.
	 *
	 * @param skirmishAIId Skirmish AI index
	 * @param reason see ...?
	 */
	//void SkirmishAILeft(int skirmishAIId, unsigned char reason);

	/**
	 * This may only be called for local AIs.
	 * This only sends a message to the server, and real destruction happens
	 * when receiving the answer.
	 * @param skirmishAIId index of the AI to destroy
	 * @param reason for a list of values, see SReleaseEvent in ExternalAI/Interface/AISEvents.h
	 * @see EngineOutHandler::DestroySkirmishAI()
	 */
	void SetSkirmishAIDieing(const size_t skirmishAIId, const int reason);
	/**
	 * Returns a value explaining why a Skirmish AI is diein, or a value < 0
	 * if it is not dieing.
	 * @param skirmishAIId index of the AI in question
	 * @return for a list of values, see SReleaseEvent in ExternalAI/Interface/AISEvents.h
	 * @see IsSkirmishAIDieing()
	 */
	int GetSkirmishAIDieReason(const size_t skirmishAIId) const;
	/**
	 * Reports true even before the DIEING state was received
	 * from the server, but only for local AIs.
	 * @param skirmishAIId index of the AI in question
	 */
	bool IsSkirmishAIDieing(const size_t skirmishAIId) const;

	/**
	 * Returns the library key for a local Skirmish AI, or NULL.
	 */
	const SkirmishAIKey* GetSkirmishAILibraryKey(const size_t skirmishAIId) const;

	//const std::vector<std::string>& GetSkirmishAIOptionValueKeys(int teamId) const;
	//const std::map<std::string, std::string>& GetSkirmishAIOptionValues(int teamId) const;

	//const T_skirmishAIInfos& GetUsedSkirmishAIInfos();

	bool IsLocalSkirmishAI(const size_t skirmishAIId) const;

private:
	static bool IsLocalSkirmishAI(const SkirmishAIData& aiData);

private:
	/// The Id reserved of for the next AI that will be added.
	//size_t nextId;

	typedef std::map<size_t, SkirmishAIData> id_ai_t;
	/// Id -> AI instance
	id_ai_t id_ai;

	/*std::map<int, std::vector<std::string> > teamId_skirmishAIOptionValueKeys;
	static const std::vector<std::string> EMPTY_OPTION_VALUE_KEYS;
	std::map<int, std::map<std::string, std::string> > teamId_skirmishAIOptionValues;
	static const std::map<std::string, std::string> EMPTY_OPTION_VALUES;

	T_skirmishAIInfos usedSkirmishAIInfos;
	bool usedSkirmishAIInfos_initialized;*/

	/// Temporarly stores reason for killing a Skirmish AI
	std::map<size_t, int> id_dieReason;

	typedef std::map<size_t, SkirmishAIKey> id_libKey_t;
	/// Id -> AI instance library key
	id_libKey_t id_libKey;

	static CSkirmishAIHandler* mySingleton;
};

#define skirmishAIHandler CSkirmishAIHandler::GetInstance()

#endif // __SKIRMISH_AI_HANDLER_H
